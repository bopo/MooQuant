--- mooquant/bar.py	(original)
+++ mooquant/bar.py	(refactored)
@@ -44,15 +44,13 @@
     MONTH = 24*60*60*31
 
 
-class Bar(object):
+@six.add_metaclass(abc.ABCMeta)
+class Bar(object):
 
     """A Bar is a summary of the trading activity for a security in a given period.
 
     .. note::
         This is a base class and should not be used directly.
     """
-
-    __metaclass__ = abc.ABCMeta
 
     @abc.abstractmethod
     def setUseAdjustedValue(self, useAdjusted):
@@ -259,7 +257,7 @@
         # Check that bar datetimes are in sync
         firstDateTime = None
         firstInstrument = None
-        for instrument, currentBar in barDict.iteritems():
+        for instrument, currentBar in six.iteritems(barDict):
             if firstDateTime is None:
                 firstDateTime = currentBar.getDateTime()
                 firstInstrument = instrument
@@ -284,14 +282,14 @@
         return instrument in self.__barDict
 
     def items(self):
-        return self.__barDict.items()
+        return list(self.__barDict.items())
 
     def keys(self):
-        return self.__barDict.keys()
+        return list(self.__barDict.keys())
 
     def getInstruments(self):
         """Returns the instrument symbols."""
-        return self.__barDict.keys()
+        return list(self.__barDict.keys())
 
     def getDateTime(self):
         """Returns the :class:`datetime.datetime` for this set of bars."""
--- mooquant/eventprofiler.py	(original)
+++ mooquant/eventprofiler.py	(refactored)
@@ -32,11 +32,11 @@
 
         self.__lookBack = lookBack
         self.__lookForward = lookForward
-        self.__values = [[] for i in xrange(lookBack+lookForward+1)]
+        self.__values = [[] for i in range(lookBack+lookForward+1)]
         self.__eventCount = 0
 
         # Process events.
-        for instrument, events in eventsDict.items():
+        for instrument, events in list(eventsDict.items()):
             for event in events:
                 
                 # Skip events which are on the boundary or for some reason are not complete.
@@ -155,7 +155,7 @@
     def __addPastReturns(self, instrument, event):
         begin = (event.getLookBack() + 1) * -1
 
-        for t in xrange(begin, 0):
+        for t in range(begin, 0):
             try:
                 ret = self.__rets[instrument][t]
 
@@ -236,7 +236,7 @@
     y = []
     std = []
 
-    for t in xrange(profilerResults.getLookBack()*-1, profilerResults.getLookForward()+1):
+    for t in range(profilerResults.getLookBack()*-1, profilerResults.getLookForward()+1):
         x.append(t)
         values = np.asarray(profilerResults.getValues(t))
         y.append(values.mean())
--- mooquant/observer.py	(original)
+++ mooquant/observer.py	(refactored)
@@ -64,9 +64,7 @@
             self.__applyChanges()
 
 
-class Subject(object):
-    __metaclass__ = abc.ABCMeta
-
+@six.add_metaclass(abc.ABCMeta)
+class Subject(object):
     def __init__(self):
         self.__dispatchPrio = dispatchprio.LAST
 
--- mooquant/plotter.py	(original)
+++ mooquant/plotter.py	(refactored)
@@ -24,7 +24,7 @@
 from matplotlib import ticker
 from mooquant import warninghelpers
 
-import broker
+from . import broker
 
 
 def get_last_value(dataSeries):
@@ -54,12 +54,12 @@
             return True
 
     dateTimeFilter = DateTimeFilter(fromDate, toDate)
-    return filter(lambda x: dateTimeFilter.includeDateTime(x), dateTimes)
+    return [x for x in dateTimes if dateTimeFilter.includeDateTime(x)]
 
 
 def _post_plot_fun(subPlot, mplSubplot):
     # Legend
-    mplSubplot.legend(subPlot.getAllSeries().keys(), shadow=True, loc="best")
+    mplSubplot.legend(list(subPlot.getAllSeries().keys()), shadow=True, loc="best")
     
     # Don't scale the Y axis
     mplSubplot.yaxis.set_major_formatter(ticker.ScalarFormatter(useOffset=False))
@@ -274,7 +274,7 @@
     def onBars(self, bars):
         dateTime = bars.getDateTime()
         
-        for cb, series in self.__callbacks.iteritems():
+        for cb, series in six.iteritems(self.__callbacks):
             series.addValue(dateTime, cb(bars))
 
     def getSeries(self, name, defaultClass=LineMarker):
@@ -290,7 +290,7 @@
         return self.getSeries(name, CustomMarker)
 
     def plot(self, mplSubplot, dateTimes, postPlotFun=_post_plot_fun):
-        for series in self.__series.values():
+        for series in list(self.__series.values()):
             color = None
             
             if series.needColor():
@@ -374,11 +374,11 @@
                 self.__checkCreateInstrumentSubplot(instrument)
 
         # Notify named subplots.
-        for subplot in self.__namedSubplots.values():
+        for subplot in list(self.__namedSubplots.values()):
             subplot.onBars(bars)
 
         # Notify bar subplots.
-        for subplot in self.__barSubplots.values():
+        for subplot in list(self.__barSubplots.values()):
             subplot.onBars(bars)
 
         # Feed the portfolio evolution subplot.
@@ -389,7 +389,7 @@
 
     def __onOrderEvent(self, broker_, orderEvent):
         # Notify BarSubplots
-        for subplot in self.__barSubplots.values():
+        for subplot in list(self.__barSubplots.values()):
             subplot.onOrderEvent(broker_, orderEvent)
 
     def getInstrumentSubplot(self, instrument):
@@ -432,8 +432,8 @@
         dateTimes.sort()
 
         subplots = []
-        subplots.extend(self.__barSubplots.values())
-        subplots.extend(self.__namedSubplots.values())
+        subplots.extend(list(self.__barSubplots.values()))
+        subplots.extend(list(self.__namedSubplots.values()))
 
         if self.__portfolioSubplot is not None:
             subplots.append(self.__portfolioSubplot)
--- mooquant/resamplebase.py	(original)
+++ mooquant/resamplebase.py	(refactored)
@@ -22,9 +22,7 @@
 from mooquant.utils import dt
 
 
-class TimeRange(object):
-    __metaclass__ = abc.ABCMeta
-
+@six.add_metaclass(abc.ABCMeta)
+class TimeRange(object):
     @abc.abstractmethod
     def belongs(self, dateTime):
         raise NotImplementedError()
@@ -144,9 +142,7 @@
     return ret
 
 
-class Grouper(object):
-    __metaclass__ = abc.ABCMeta
-
+@six.add_metaclass(abc.ABCMeta)
+class Grouper(object):
     def __init__(self, groupDateTime):
         self.__groupDateTime = groupDateTime
 
--- mooquant/barfeed/csvfeed.py	(original)
+++ mooquant/barfeed/csvfeed.py	(refactored)
@@ -191,7 +191,7 @@
         # Process extra columns.
         extra = {}
 
-        for k, v in csvRowDict.iteritems():
+        for k, v in six.iteritems(csvRowDict):
             if k not in self.__columnNames:
                 extra[k] = csvutils.float_or_string(v)
 
--- mooquant/barfeed/membf.py	(original)
+++ mooquant/barfeed/membf.py	(refactored)
@@ -39,7 +39,7 @@
     def reset(self):
         self.__nextPos = {}
 
-        for instrument in self.__bars.keys():
+        for instrument in list(self.__bars.keys()):
             self.__nextPos.setdefault(instrument, 0)
 
         self.__currDateTime = None
@@ -75,7 +75,7 @@
     def eof(self):
         ret = True
         # Check if there is at least one more bar to return.
-        for instrument, bars in self.__bars.iteritems():
+        for instrument, bars in self.__bars.items():
             nextPos = self.__nextPos[instrument]
 
             if nextPos < len(bars):
@@ -87,7 +87,7 @@
     def peekDateTime(self):
         ret = None
 
-        for instrument, bars in self.__bars.iteritems():
+        for instrument, bars in self.__bars.items():
             nextPos = self.__nextPos[instrument]
             if nextPos < len(bars):
                 ret = utils.safe_min(ret, bars[nextPos].getDateTime())
@@ -103,14 +103,14 @@
 
         # Make a second pass to get all the bars that had the smallest datetime.
         ret = {}
-        for instrument, bars in self.__bars.iteritems():
+        for instrument, bars in self.__bars.items():
             nextPos = self.__nextPos[instrument]
             if nextPos < len(bars) and bars[nextPos].getDateTime() == smallestDateTime:
                 ret[instrument] = bars[nextPos]
                 self.__nextPos[instrument] += 1
 
         if self.__currDateTime == smallestDateTime:
-            raise Exception("Duplicate bars found for %s on %s" % (ret.keys(), smallestDateTime))
+            raise Exception("Duplicate bars found for %s on %s" % (list(ret.keys()), smallestDateTime))
 
         self.__currDateTime = smallestDateTime
         return bar.Bars(ret)
--- mooquant/barfeed/resampled.py	(original)
+++ mooquant/barfeed/resampled.py	(refactored)
@@ -26,13 +26,13 @@
         self.__frequency = frequency
 
         # Initialize BarGrouper instances for each instrument.
-        for instrument, bar_ in bars.items():
+        for instrument, bar_ in list(bars.items()):
             barGrouper = resampled.BarGrouper(groupDateTime, bar_, frequency)
             self.__barGroupers[instrument] = barGrouper
 
     def addValue(self, value):
         # Update or initialize BarGrouper instances for each instrument.
-        for instrument, bar_ in value.items():
+        for instrument, bar_ in list(value.items()):
             barGrouper = self.__barGroupers.get(instrument)
             if barGrouper:
                 barGrouper.addValue(bar_)
@@ -43,7 +43,7 @@
     def getGrouped(self):
         bar_dict = {}
         
-        for instrument, grouper in self.__barGroupers.items():
+        for instrument, grouper in list(self.__barGroupers.items()):
             bar_dict[instrument] = grouper.getGrouped()
         
         return bar.Bars(bar_dict)
--- mooquant/bitstamp/httpclient.py	(original)
+++ mooquant/bitstamp/httpclient.py	(refactored)
@@ -225,9 +225,7 @@
         jsonResponse = self._post(url, {})
         
         if transactionType is not None:
-            jsonUserTransactions = filter(
-                lambda jsonUserTransaction: jsonUserTransaction["type"] == transactionType, jsonResponse
-            )
+            jsonUserTransactions = [jsonUserTransaction for jsonUserTransaction in jsonResponse if jsonUserTransaction["type"] == transactionType]
         else:
             jsonUserTransactions = jsonResponse
         return [UserTransaction(jsonUserTransaction) for jsonUserTransaction in jsonUserTransactions]
--- mooquant/bitstamp/livebroker.py	(original)
+++ mooquant/bitstamp/livebroker.py	(refactored)
@@ -18,7 +18,7 @@
 .. moduleauthor:: Gabriel Martin Becedillas Ruiz <gabriel.becedillas@gmail.com>
 """
 
-import Queue
+try:
+    import Queue as queue
+except ImportError:
+    import queue
 import threading
 import time
 
@@ -51,7 +51,7 @@
         super(TradeMonitor, self).__init__()
         self.__lastTradeId = -1
         self.__httpClient = httpClient
-        self.__queue = Queue.Queue()
+        self.__queue = queue.Queue()
         self.__stop = False
 
     def _getNewTrades(self):
@@ -90,7 +90,7 @@
                     self.__lastTradeId = trades[-1].getId()
                     common.logger.info("%d new trade/s found" % (len(trades)))
                     self.__queue.put((TradeMonitor.ON_USER_TRADE, trades))
-            except Exception, e:
+            except Exception as e:
                 common.logger.critical("Error retrieving user transactions", exc_info=e)
 
             time.sleep(TradeMonitor.POLL_FREQUENCY)
@@ -239,7 +239,7 @@
 
     def dispatch(self):
         # Switch orders from SUBMITTED to ACCEPTED.
-        ordersToProcess = self.__activeOrders.values()
+        ordersToProcess = list(self.__activeOrders.values())
         for order in ordersToProcess:
             if order.isSubmitted():
                 order.switchState(broker.Order.State.ACCEPTED)
@@ -253,7 +253,7 @@
                 self._onUserTrades(eventData)
             else:
                 common.logger.error("Invalid event received to dispatch: %s - %s" % (eventType, eventData))
-        except Queue.Empty:
+        except queue.Empty:
             pass
 
     def peekDateTime(self):
@@ -277,7 +277,7 @@
         return self.__shares
 
     def getActiveOrders(self, instrument=None):
-        return self.__activeOrders.values()
+        return list(self.__activeOrders.values())
 
     def submitOrder(self, order):
         if order.isInitial():
--- mooquant/bitstamp/livefeed.py	(original)
+++ mooquant/bitstamp/livefeed.py	(refactored)
@@ -19,7 +19,7 @@
 """
 
 import datetime
-import Queue
+try:
+    import Queue as queue
+except ImportError:
+    import queue
 import time
 
 from mooquant import bar, barfeed, observer
@@ -134,7 +134,7 @@
             # Start the thread that runs the client.
             self.__thread = self.buildWebSocketClientThread()
             self.__thread.start()
-        except Exception, e:
+        except Exception as e:
             self.__initializationOk = False
             common.logger.error("Error connecting : %s" % str(e))
 
@@ -181,7 +181,7 @@
             else:
                 ret = False
                 common.logger.error("Invalid event received to dispatch: %s - %s" % (eventType, eventData))
-        except Queue.Empty:
+        except queue.Empty:
             pass
         return ret
 
@@ -239,7 +239,7 @@
             if self.__thread is not None and self.__thread.is_alive():
                 common.logger.info("Shutting down websocket client.")
                 self.__thread.stop()
-        except Exception, e:
+        except Exception as e:
             common.logger.error("Error shutting down client: %s" % (str(e)))
 
     # This should not raise.
--- mooquant/bitstamp/wsclient.py	(original)
+++ mooquant/bitstamp/wsclient.py	(refactored)
@@ -19,7 +19,7 @@
 """
 
 import datetime
-import Queue
+try:
+    import Queue as queue
+except ImportError:
+    import queue
 import threading
 
 from mooquant.bitstamp import common
@@ -103,7 +103,7 @@
 
     def __init__(self):
         super(WebSocketClient, self).__init__(WebSocketClient.PUSHER_APP_KEY, 5)
-        self.__queue = Queue.Queue()
+        self.__queue = queue.Queue()
 
     def getQueue(self):
         return self.__queue
@@ -132,7 +132,7 @@
         common.logger.warning("Disconnection detected.")
         try:
             self.stopClient()
-        except Exception, e:
+        except Exception as e:
             common.logger.error("Error stopping websocket client: %s." % (str(e)))
         self.__queue.put((WebSocketClient.ON_DISCONNECTED, None))
 
@@ -180,5 +180,5 @@
         try:
             common.logger.info("Stopping websocket client.")
             self.__wsClient.stopClient()
-        except Exception, e:
+        except Exception as e:
             common.logger.error("Error stopping websocket client: %s." % (str(e)))
--- mooquant/broker/__init__.py	(original)
+++ mooquant/broker/__init__.py	(refactored)
@@ -26,11 +26,8 @@
 # Why not use decimal.Decimal instead ?
 # 1: I'd have to expose this to users. They'd have to deal with decimal.Decimal and it'll break existing users.
 # 2: numpy arrays built using decimal.Decimal instances have dtype=object.
-class InstrumentTraits(object):
-
-    __metaclass__ = abc.ABCMeta
-
-    # Return the floating point value number rounded.
+@six.add_metaclass(abc.ABCMeta)
+class InstrumentTraits(object):
+
     @abc.abstractmethod
     def roundQuantity(self, quantity):
         raise NotImplementedError()
@@ -486,15 +483,13 @@
 
 ######################################################################
 # Base broker class
-class Broker(observer.Subject):
+class Broker(observer.Subject):
     """Base class for brokers.
 
     .. note::
 
         This is a base class and should not be used directly.
     """
-
-    __metaclass__ = abc.ABCMeta
 
     def __init__(self):
         super(Broker, self).__init__()
--- mooquant/broker/backtesting.py	(original)
+++ mooquant/broker/backtesting.py	(refactored)
@@ -27,14 +27,12 @@
 ######################################################################
 # Commission models
 
-class Commission(object):
+@six.add_metaclass(abc.ABCMeta)
+class Commission(object):
     """Base class for implementing different commission schemes.
 
     .. note::
         This is a base class and should not be used directly.
     """
-
-    __metaclass__ = abc.ABCMeta
 
     @abc.abstractmethod
     def calculate(self, order, price, quantity):
@@ -239,7 +237,7 @@
         
         if not includeShort and self.__barFeed.getCurrentBars() is not None:
             bars = self.__barFeed.getCurrentBars()
-            for instrument, shares in self.__shares.iteritems():
+            for instrument, shares in six.iteritems(self.__shares):
                 if shares < 0:
                     instrumentPrice = self._getBar(bars, instrument).getClose(self.getUseAdjustedValues())
                     ret += instrumentPrice * shares
@@ -284,9 +282,9 @@
 
     def getActiveOrders(self, instrument=None):
         if instrument is None:
-            ret = self.__activeOrders.values()
+            ret = list(self.__activeOrders.values())
         else:
-            ret = [order for order in self.__activeOrders.values() if order.getInstrument() == instrument]
+            ret = [order for order in list(self.__activeOrders.values()) if order.getInstrument() == instrument]
         
         return ret
 
@@ -303,12 +301,12 @@
         return self.__shares
 
     def getActiveInstruments(self):
-        return [instrument for instrument, shares in self.__shares.iteritems() if shares != 0]
+        return [instrument for instrument, shares in self.__shares.items() if shares != 0]
 
     def __getEquityWithBars(self, bars):
         ret = self.getCash()
         if bars is not None:
-            for instrument, shares in self.__shares.iteritems():
+            for instrument, shares in six.iteritems(self.__shares):
                 instrumentPrice = self._getBar(bars, instrument).getClose(self.getUseAdjustedValues())
                 ret += instrumentPrice * shares
         
@@ -459,7 +457,7 @@
 
         # This is to froze the orders that will be processed in this event, to avoid new getting orders introduced
         # and processed on this very same event.
-        ordersToProcess = self.__activeOrders.values()
+        ordersToProcess = list(self.__activeOrders.values())
 
         for order in ordersToProcess:
             # This may trigger orders to be added/removed from __activeOrders.
--- mooquant/broker/fillstrategy.py	(original)
+++ mooquant/broker/fillstrategy.py	(refactored)
@@ -23,7 +23,7 @@
 import mooquant.bar
 from mooquant import broker
 
-import slippage
+from . import slippage
 
 
 # Returns the trigger price for a Limit or StopLimit order, or None if the limit price was not yet penetrated.
@@ -104,10 +104,8 @@
         return self.__quantity
 
 
-class FillStrategy(object):
+@six.add_metaclass(abc.ABCMeta)
+class FillStrategy(object):
     """Base class for order filling strategies for the backtester."""
-
-    __metaclass__ = abc.ABCMeta
 
     def onBars(self, broker_, bars):
         """
--- mooquant/broker/slippage.py	(original)
+++ mooquant/broker/slippage.py	(refactored)
@@ -21,14 +21,12 @@
 import abc
 
 
-class SlippageModel(object):
+@six.add_metaclass(abc.ABCMeta)
+class SlippageModel(object):
     """Base class for slippage models.
 
     .. note::
         This is a base class and should not be used directly.
     """
-
-    __metaclass__ = abc.ABCMeta
 
     @abc.abstractmethod
     def calculatePrice(self, order, price, quantity, bar, volumeUsed):
--- mooquant/dataseries/__init__.py	(original)
+++ mooquant/dataseries/__init__.py	(refactored)
@@ -38,14 +38,12 @@
 
 # It is important to inherit object to get __getitem__ to work properly.
 # Check http://code.activestate.com/lists/python-list/621258/
-class DataSeries(object):
+@six.add_metaclass(abc.ABCMeta)
+class DataSeries(object):
     """Base class for data series.
 
     .. note::
         This is a base class and should not be used directly.
     """
-
-    __metaclass__ = abc.ABCMeta
 
     @abc.abstractmethod
     def __len__(self):
@@ -56,7 +54,7 @@
         """Returns the value at a given position/slice. It raises IndexError if the position is invalid,
         or TypeError if the key type is invalid."""
         if isinstance(key, slice):
-            return [self[i] for i in xrange(*key.indices(len(self)))]
+            return [self[i] for i in range(*key.indices(len(self)))]
         elif isinstance(key, int):
             if key < 0:
                 key += len(self)
--- mooquant/dataseries/bards.py	(original)
+++ mooquant/dataseries/bards.py	(refactored)
@@ -71,7 +71,7 @@
         self.__adjCloseDS.appendWithDateTime(dateTime, bar.getAdjClose())
 
         # Process extra columns.
-        for name, value in bar.getExtraColumns().iteritems():
+        for name, value in six.iteritems(bar.getExtraColumns()):
             extraDS = self.__getOrCreateExtraDS(name)
             extraDS.appendWithDateTime(dateTime, value)
 
--- mooquant/dataseries/resampled.py	(original)
+++ mooquant/dataseries/resampled.py	(refactored)
@@ -64,9 +64,7 @@
         return ret
 
 
-class DSResampler(object):
-    __metaclass__ = abc.ABCMeta
-
+@six.add_metaclass(abc.ABCMeta)
+class DSResampler(object):
     def initDSResampler(self, dataSeries, frequency):
         if not resamplebase.is_valid_frequency(frequency):
             raise Exception("Unsupported frequency")
--- mooquant/feed/__init__.py	(original)
+++ mooquant/feed/__init__.py	(refactored)
@@ -56,7 +56,7 @@
         self.__maxLen = maxLen
 
     def reset(self):
-        keys = self.__ds.keys()
+        keys = list(self.__ds.keys())
         self.__ds = {}
         for key in keys:
             self.registerDataSeries(key)
@@ -80,7 +80,7 @@
     def getNextValuesAndUpdateDS(self):
         dateTime, values = self.getNextValues()
         if dateTime is not None:
-            for key, value in values.items():
+            for key, value in list(values.items()):
                 # Get or create the datseries for each key.
                 try:
                     ds = self.__ds[key]
@@ -109,7 +109,7 @@
         return dateTime is not None
 
     def getKeys(self):
-        return self.__ds.keys()
+        return list(self.__ds.keys())
 
     def __getitem__(self, key):
         """Returns the :class:`mooquant.dataseries.DataSeries` for a given key."""
--- mooquant/feed/csvfeed.py	(original)
+++ mooquant/feed/csvfeed.py	(refactored)
@@ -26,13 +26,8 @@
 
 
 # Interface for csv row parsers.
-class RowParser(object):
+@six.add_metaclass(abc.ABCMeta)
+class RowParser(object):
 
-    __metaclass__ = abc.ABCMeta
-
-    # Parses a row and returns a tuple with with two elements:
-    # 1: datetime.datetime.
-    # 2: dictionary or dict-like object.
     @abc.abstractmethod
     def parseRow(self, csvRowDict):
         raise NotImplementedError()
@@ -49,9 +44,7 @@
 
 
 # Interface for bar filters.
-class RowFilter(object):
-
-    __metaclass__ = abc.ABCMeta
+@six.add_metaclass(abc.ABCMeta)
+class RowFilter(object):
 
     @abc.abstractmethod
     def includeRow(self, dateTime, values):
@@ -117,7 +110,7 @@
         # Convert the values
         values = {}
         
-        for key, value in csvRowDict.items():
+        for key, value in list(csvRowDict.items()):
             if key != self.__dateTimeColumn:
                 values[key] = self.__converter(key, value)
         
--- mooquant/feed/memfeed.py	(original)
+++ mooquant/feed/memfeed.py	(refactored)
@@ -75,7 +75,7 @@
     # 2: dictionary or dict-like object.
     def addValues(self, values):
         # Register a dataseries for each item.
-        for key in values[0][1].keys():
+        for key in list(values[0][1].keys()):
             self.registerDataSeries(key)
 
         self.__values.extend(values)
--- mooquant/optimizer/base.py	(original)
+++ mooquant/optimizer/base.py	(refactored)
@@ -53,7 +53,7 @@
             if self.__iter is not None:
                 try:
                     while count > 0:
-                        params = self.__iter.next()
+                        params = six.next(self.__iter)
                         
                         # Backward compatibility when parameters don't yield Parameters.
                         if not isinstance(params, Parameters):
--- mooquant/optimizer/local.py	(original)
+++ mooquant/optimizer/local.py	(refactored)
@@ -52,7 +52,7 @@
         w = Worker("localhost", port, name)
         w.getLogger().setLevel(logLevel)
         w.run()
-    except Exception, e:
+    except Exception as e:
         w.getLogger().exception("Failed to run worker: %s" % (e))
 
 
--- mooquant/optimizer/worker.py	(original)
+++ mooquant/optimizer/worker.py	(refactored)
@@ -23,7 +23,7 @@
 import random
 import socket
 import time
-import xmlrpclib
+from xmlrpc.client import ServerProxy
 
 import mooquant.logger
 from mooquant import barfeed
@@ -49,7 +49,7 @@
 class Worker(object):
     def __init__(self, address, port, workerName=None):
         url = "http://%s:%s/PyAlgoTradeRPC" % (address, port)
-        self.__server = xmlrpclib.ServerProxy(url, allow_none=True)
+        self.__server = ServerProxy(url, allow_none=True)
         self.__logger = mooquant.logger.getLogger(workerName)
         
         if workerName is None:
@@ -100,7 +100,7 @@
             
             try:
                 result = self.runStrategy(feed, *parameters)
-            except Exception, e:
+            except Exception as e:
                 self.getLogger().exception("Error running strategy with parameters %s: %s" % (str(parameters), e))
             
             self.getLogger().info("Result %s" % result)
@@ -134,7 +134,7 @@
                 job = self.getNextJob()
             
             self.getLogger().info("Finished running")
-        except Exception, e:
+        except Exception as e:
             self.getLogger().exception("Finished running with errors: %s" % (e))
 
 
--- mooquant/optimizer/xmlrpcserver.py	(original)
+++ mooquant/optimizer/xmlrpcserver.py	(refactored)
@@ -19,7 +19,7 @@
 """
 
 import pickle
-import SimpleXMLRPCServer
+from xmlrpc.server import SimpleXMLRPCServer
 import threading
 import time
 
@@ -58,15 +58,15 @@
 
 
 # Restrict to a particular path.
-class RequestHandler(SimpleXMLRPCServer.SimpleXMLRPCRequestHandler):
+class RequestHandler(SimpleXMLRPCRequestHandler):
     rpc_paths = ('/PyAlgoTradeRPC',)
 
 
-class Server(SimpleXMLRPCServer.SimpleXMLRPCServer):
+class Server(SimpleXMLRPCServer):
     defaultBatchSize = 200
 
     def __init__(self, paramSource, resultSinc, barFeed, address, port, autoStop=True):
-        SimpleXMLRPCServer.SimpleXMLRPCServer.__init__(self, (address, port), requestHandler=RequestHandler, logRequests=False, allow_none=True)
+        SimpleXMLRPCServer.__init__(self, (address, port), requestHandler=RequestHandler, logRequests=False, allow_none=True)
         # super(Server, self).__init__((address, port), requestHandler=RequestHandler, logRequests=False, allow_none=True)
 
         self.__paramSource = paramSource
@@ -101,7 +101,7 @@
 
         # Get the next set of parameters.
         params = self.__paramSource.getNext(self.defaultBatchSize)
-        params = map(lambda p: p.args, params)
+        params = [p.args for p in params]
 
         # Map the active job
         if len(params):
--- mooquant/strategy/__init__.py	(original)
+++ mooquant/strategy/__init__.py	(refactored)
@@ -30,7 +30,7 @@
 from mooquant.barfeed import resampled
 
 
-class BaseStrategy(object):
+@six.add_metaclass(abc.ABCMeta)
+class BaseStrategy(object):
     """Base class for strategies.
 
     :param barFeed: The bar feed that will supply the bars.
@@ -41,8 +41,6 @@
     .. note::
         This is a base class and should not be used directly.
     """
-
-    __metaclass__ = abc.ABCMeta
 
     LOGGER_NAME = "strategy"
 
--- mooquant/strategy/position.py	(original)
+++ mooquant/strategy/position.py	(refactored)
@@ -206,7 +206,7 @@
         return self.__strategy.getLastPrice(self.getInstrument())
 
     def getActiveOrders(self):
-        return self.__activeOrders.values()
+        return list(self.__activeOrders.values())
 
     def getShares(self):
         """Returns the number of shares.
--- mooquant/technical/cross.py	(original)
+++ mooquant/technical/cross.py	(refactored)
@@ -59,7 +59,7 @@
     # Compute differences and check sign changes.
     ret = 0
     diffs = compute_diff(values1, values2)
-    diffs = filter(lambda x: x != 0, diffs)
+    diffs = [x for x in diffs if x != 0]
 
     prevDiff = None
 
--- mooquant/technical/linreg.py	(original)
+++ mooquant/technical/linreg.py	(refactored)
@@ -103,7 +103,7 @@
 class SlopeEventWindow(technical.EventWindow):
     def __init__(self, windowSize):
         super(SlopeEventWindow, self).__init__(windowSize)
-        self.__x = np.asarray(range(windowSize))
+        self.__x = np.asarray(list(range(windowSize)))
 
     def getValue(self):
         ret = None
--- mooquant/technical/rsi.py	(original)
+++ mooquant/technical/rsi.py	(refactored)
@@ -63,7 +63,7 @@
     gain = 0
     loss = 0
 
-    for i in xrange(begin+1, end):
+    for i in range(begin+1, end):
         currGain, currLoss = gain_loss_one(values[i-1], values[i])
         gain += currGain
         loss += currLoss
@@ -79,7 +79,7 @@
 
     avgGain, avgLoss = avg_gain_loss(values, 0, period)
 
-    for i in xrange(period, len(values)):
+    for i in range(period, len(values)):
         gain, loss = gain_loss_one(values[i-1], values[i])
         avgGain = (avgGain * (period - 1) + gain) / float(period)
         avgLoss = (avgLoss * (period - 1) + loss) / float(period)
--- mooquant/tools/googlefinance.py	(original)
+++ mooquant/tools/googlefinance.py	(refactored)
@@ -103,7 +103,7 @@
                         download_daily_bars(instrument, year, fileName)
                     else:
                         raise Exception("Invalid frequency")
-                except Exception, e:
+                except Exception as e:
                     if skipErrors:
                         logger.error(str(e))
                         continue
--- mooquant/tools/quandl.py	(original)
+++ mooquant/tools/quandl.py	(refactored)
@@ -132,7 +132,7 @@
         ret.setNoAdjClose()
 
     # Additional column names.
-    for col, name in columnNames.iteritems():
+    for col, name in six.iteritems(columnNames):
         ret.setColumnName(col, name)
 
     if not os.path.exists(storage):
@@ -152,7 +152,7 @@
                         download_weekly_bars(sourceCode, tableCode, year, fileName, authToken)
                     else:
                         raise Exception("Invalid frequency")
-                except Exception, e:
+                except Exception as e:
                     if skipErrors:
                         logger.error(str(e))
                         continue
--- mooquant/tools/yahoofinance.py	(original)
+++ mooquant/tools/yahoofinance.py	(refactored)
@@ -116,7 +116,7 @@
                         download_weekly_bars(instrument, year, fileName)
                     else:
                         raise Exception("Invalid frequency")
-                except Exception, e:
+                except Exception as e:
                     if skipErrors:
                         logger.error(str(e))
                         continue
--- mooquant/twitter/feed.py	(original)
+++ mooquant/twitter/feed.py	(refactored)
@@ -19,7 +19,7 @@
 """
 
 import json
-import Queue
+try:
+    import Queue as queue
+except ImportError:
+    import queue
 import threading
 
 import mooquant.logger
@@ -92,7 +92,7 @@
         super(TwitterFeed, self).__init__()
 
         self.__event = observer.Event()
-        self.__queue = Queue.Queue()
+        self.__queue = queue.Queue()
         self.__thread = None
         self.__running = False
 
@@ -121,7 +121,7 @@
             nextTweet = json.loads(self.__queue.get(True, TwitterFeed.QUEUE_TIMEOUT))
             ret = True
             self.__event.emit(nextTweet)
-        except Queue.Empty:
+        except queue.Empty:
             pass
 
         return ret
@@ -148,7 +148,7 @@
             if self.__thread is not None and self.__thread.is_alive():
                 logger.info("Shutting down client.")
                 self.__stream.disconnect()
-        except Exception, e:
+        except Exception as e:
             logger.error("Error disconnecting stream: %s." % (str(e)))
 
     def join(self):
--- mooquant/utils/csvutils.py	(original)
+++ mooquant/utils/csvutils.py	(refactored)
@@ -32,25 +32,25 @@
         self.reader = csv.reader(f, dialect, *args, **kwargs)
 
         if self.__fieldNames is None:
-            self.__fieldNames = self.reader.next()
+            self.__fieldNames = six.next(self.reader)
 
         self.__dict = {}
 
     def __iter__(self):
         return self
 
-    def next(self):
+    def __next__(self):
         # Skip empty rows.
-        row = self.reader.next()
+        row = six.next(self.reader)
 
         while row == []:
-            row = self.reader.next()
+            row = six.next(self.reader)
 
         # Check that the row has the right number of columns.
         assert(len(self.__fieldNames) == len(row))
 
         # Copy the row values into the dict.
-        for i in xrange(len(self.__fieldNames)):
+        for i in range(len(self.__fieldNames)):
             self.__dict[self.__fieldNames[i]] = row[i]
 
         return self.__dict
--- mooquant/websocket/client.py	(original)
+++ mooquant/websocket/client.py	(refactored)
@@ -130,7 +130,7 @@
                     return
 
             self.onMessage(msg)
-        except Exception, e:
+        except Exception as e:
             self.onUnhandledException(e)
 
     def opened(self):
@@ -168,7 +168,7 @@
 
             self.close_connection()
 
-        except Exception, e:
+        except Exception as e:
             logger.warning("Failed to close connection: %s" % (e))
 
     ######################################################################
--- mooquant/websocket/pusher.py	(original)
+++ mooquant/websocket/pusher.py	(refactored)
@@ -19,7 +19,7 @@
 """
 
 import json
-import urllib
+try:
+    from urllib import urlencode
+except ImportError:
+    from urllib.parse import urlencode
 import mooquant
 import mooquant.logger
@@ -77,7 +77,7 @@
             "version": mooquant.__version__
             }
 
-        url = "ws://ws.pusherapp.com/app/%s?%s" % (appKey, urllib.urlencode(params))
+        url = "ws://ws.pusherapp.com/app/%s?%s" % (appKey, urlencode(params))
         super(WebSocketClient, self).__init__(url)
         self.setKeepAliveMgr(PingKeepAliveMgr(self, maxInactivity, responseTimeout))
 
